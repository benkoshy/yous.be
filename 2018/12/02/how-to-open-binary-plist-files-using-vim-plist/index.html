<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>How to open binary plist files using vim-plist</title><meta name="description" content="How to open binary plist files when it&#39;s extension is not .plist."><meta name="keywords" content="vim, plist, binary, vim-plist"><link rel="stylesheet" href="/assets/main.css"><link rel="canonical" href="https://yous.be/2018/12/02/how-to-open-binary-plist-files-using-vim-plist/"><link rel="alternate" type="application/rss+xml" title="Yous" href="https://yous.be/atom.xml"><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="icon" type="image/png" href="/icon-192x192.png"><link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="167x167" href="/apple-touch-icon-167x167.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png"><link rel="mask-icon" color="#2568ba" href="/safari-pinned-tab.svg"><meta name="msapplication-TileColor" content="#2568ba"><meta name="msapplication-TileImage" content="/mstile-144x144.png"><meta property="fb:admins" content="100001802412550"><meta property="og:title" content="How to open binary plist files using vim-plist"><meta property="og:site_name" content="Yous"><meta property="og:url" content="https://yous.be/2018/12/02/how-to-open-binary-plist-files-using-vim-plist/"><meta property="og:description" content="How to open binary plist files when it&#39;s extension is not .plist."><meta property="og:image" content="https://yous.be/images/2018/12/02/plist.png"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="How to open binary plist files using vim-plist"><meta name="twitter:description" content="How to open binary plist files when it&#39;s extension is not .plist."><meta name="twitter:image:src" content="https://yous.be/images/2018/12/02/plist.png"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css?family=Bitter:400,400i,700" rel="stylesheet"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-43111808-1', 'auto'); ga('send', 'pageview'); </script><body><header class="site-header"><div class="wrapper"> <a class="site-title" href="/">Yous</a><nav class="site-nav"> <a class="page-link" href="/about/">About</a> <a class="page-link" href="/archives/">Archives</a></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header class="post-header"><h1 class="post-title" itemprop="name headline">How to open binary plist files using vim-plist</h1><p class="post-meta"><time datetime="2018-12-02T08:42:47+00:00" itemprop="datePublished">Dec 2, 2018</time> • <a href="/categories/vim/">Vim</a></p></header><div class="post-content" itemprop="articleBody"><p><img src="/images/2018/12/02/plist.png" alt="Vim editing a binary plist file" title="Vim editing a binary plist file" /></p><p>Using macOS, you may have had experiences of handling plist files. For example, <code class="highlighter-rouge">~/Library/Preferences/.GlobalPreferences.plist</code> file holds some configurations of macOS. When you type <code class="highlighter-rouge">defaults write -g ApplePressAndHoldEnabled -bool false</code> on terminal, the following lines are added to <code class="highlighter-rouge">.GlobalPreferences.plist</code>:</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;key&gt;</span>ApplePressAndHoldEnabled<span class="nt">&lt;/key&gt;</span>
<span class="nt">&lt;false/&gt;</span>
</code></pre></div></div><p>So when you dig down the preferences or resources of macOS system, you’ll meet plist files.</p><h2>vim-plist</h2><p>darfink’s <a href="https://github.com/darfink/vim-plist">vim-plist</a> plugin handles *.plist files quite well. A plist file is in one of three formats; json, binary, xml. macOS is bundled with the <code class="highlighter-rouge">plutil</code> command that can convert a plist file from one format to another. The plugin also uses <code class="highlighter-rouge">plutil</code> to handle read and write of plist files.</p><p>The plugin registers autocmd for <a href="https://github.com/darfink/vim-plist/blob/67280fb32b88ad75e255068dfe69b9f069421618/plugin/plist.vim#L19-L20"><code class="highlighter-rouge">BufReadCmd</code> and <code class="highlighter-rouge">FileReadCmd</code></a> to read *.plist files, <a href="https://github.com/darfink/vim-plist/blob/67280fb32b88ad75e255068dfe69b9f069421618/plugin/plist.vim#L16"><code class="highlighter-rouge">BufWriteCmd</code> and <code class="highlighter-rouge">FileWriteCmd</code></a> to write *.plist files. <code class="highlighter-rouge">BufRead</code> and <code class="highlighter-rouge">BufWrite</code> events are triggered <em>after</em> reading the file into the buffer, but <code class="highlighter-rouge">BufReadCmd</code> and <code class="highlighter-rouge">BufWriteCmd</code> events are triggered <em>before</em> reading the file, and that autocmd should handle actual read and write operation of that file. These differences make handling plist files more complex.</p><h2>Problems</h2><h3>*.strings files</h3><p>Overall, the plugin is quite useful and seamless. But recently, I found some *.strings plist files under <code class="highlighter-rouge">/System/Library</code>, almost of them in binary formats. The plugin registers autocmds only for *.plist files, so there is no chance to convert them to readable formats.</p><p>At first, I’ve considered to register an autocmd for *.strings file, but I’m not sure about that <code class="highlighter-rouge">.strings</code> extension is only used for plist file, and also there can be other extensions with plist contents (for example, *.nib files are plist, too).</p><h3>Saving a new file</h3><p>darfink’s vim-plist checks <code class="highlighter-rouge">g:plist_save_format</code> and <code class="highlighter-rouge">b:plist_save_format</code> before writing to plist files. The buffer-local variable is set when the plugin reads the file and detect the format. The global one is set by user, and overrides buffer-local one.</p><p>I don’t want the plugin to override the content of plist files with different format, so I haven’t set <code class="highlighter-rouge">g:plist_save_format</code>. Then the problem raised. Open a new plist file, like <code class="highlighter-rouge">vim test.plist</code>, and save it after editing. Then the plugin didn’t set <code class="highlighter-rouge">b:plist_save_format</code> because it’s a new file, and I also didn’t set <code class="highlighter-rouge">g:plist_save_format</code>, so the plugin don’t know the format to use for saving.</p><p>I think this problem can be solved by patching the plugin, but its last commit is pushed in 2014, which makes me use the faster way.</p><h2>Solving the problems with .vimrc</h2><h3>Binary plist files</h3><p>I decided to check if the file is binary plist file or not, and load with functions of vim-plist plugin. The checking process is easy, because the file starts with <code class="highlighter-rouge">bplist</code>. At first, I think it’s okay to register an autocmd for <code class="highlighter-rouge">BufReadCmd</code> because calling functions of the plugin should be easy. So my first try was:</p><div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span><span class="p">!</span> <span class="nv">s:DetectBinaryPlist</span><span class="p">()</span>
  <span class="k">let</span> <span class="k">l</span><span class="p">:</span>filename <span class="p">=</span> expand<span class="p">(</span><span class="s1">'&lt;afile&gt;'</span><span class="p">)</span>
  <span class="k">if</span> filereadable<span class="p">(</span><span class="k">l</span><span class="p">:</span>filename<span class="p">)</span>
    <span class="k">let</span> <span class="k">l</span><span class="p">:</span>content <span class="p">=</span> readfile<span class="p">(</span><span class="k">l</span><span class="p">:</span>filename<span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
    <span class="k">if</span> len<span class="p">(</span>content<span class="p">)</span> <span class="p">&gt;</span> <span class="m">0</span> &amp;&amp; content<span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=~</span># <span class="s1">'^bplist'</span>
      <span class="k">return</span> <span class="m">1</span>
    <span class="k">endif</span>
  <span class="k">endif</span>
  <span class="k">return</span> <span class="m">0</span>
<span class="k">endfunction</span>
autocmd <span class="nb">BufReadCmd</span> *
<span class="se">      \</span> <span class="k">if</span> <span class="nv">s:DetectBinaryPlist</span><span class="p">()</span> <span class="p">|</span>
<span class="se">      \</span>   <span class="k">call</span> plist#Read<span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="p">|</span>
<span class="se">      \</span>   <span class="k">call</span> plist#ReadPost<span class="p">()</span> <span class="p">|</span>
<span class="se">      \</span> <span class="k">endif</span>
</code></pre></div></div><p>Can you see the problem? This makes Vim returns an empty buffer when it reads a file that’s not a binary plist file. As I said above, <code class="highlighter-rouge">BufReadCmd</code> should handle actual read and write operation of the file. If it’s not a binary plist file, Vim won’t read anything according to this code.</p><p>So I changed <code class="highlighter-rouge">BufReadCmd</code> to <code class="highlighter-rouge">BufRead</code>. This event happens <em>after</em> reading the file into the buffer, so I have to empty the buffer.</p><div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span><span class="p">!</span> <span class="nv">s:ConvertBinaryPlist</span><span class="p">()</span>
  <span class="k">silent</span><span class="p">!</span> execute <span class="s1">'%d'</span>
  <span class="k">call</span> plist#Read<span class="p">(</span><span class="m">1</span><span class="p">)</span>
  <span class="k">call</span> plist#ReadPost<span class="p">()</span>
<span class="k">endfunction</span>
autocmd <span class="nb">BufRead</span> *
<span class="se">      \</span> <span class="k">if</span> getline<span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="p">=~</span># <span class="s1">'^bplist'</span> <span class="p">|</span>
<span class="se">      \</span>   <span class="k">call</span> <span class="nv">s:ConvertBinaryPlist</span><span class="p">()</span> <span class="p">|</span>
<span class="se">      \</span> <span class="k">endif</span>
</code></pre></div></div><p>The <code class="highlighter-rouge">getline(1)</code> reads the first line of the buffer, and we can call it because it’s after reading the file. It’s working quite well, so at that time, I wanted to bring the writing functionality also.</p><div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span><span class="p">!</span> <span class="nv">s:ConvertBinaryPlist</span><span class="p">()</span>
  <span class="k">silent</span><span class="p">!</span> execute <span class="s1">'%d'</span>
  <span class="k">call</span> plist#Read<span class="p">(</span><span class="m">1</span><span class="p">)</span>
  <span class="k">call</span> plist#ReadPost<span class="p">()</span>

  autocmd<span class="p">!</span> <span class="nb">BufWriteCmd</span><span class="p">,</span><span class="nb">FileWriteCmd</span> <span class="p">&lt;</span>buffer<span class="p">&gt;</span>
  autocmd <span class="nb">BufWriteCmd</span><span class="p">,</span><span class="nb">FileWriteCmd</span> <span class="p">&lt;</span>buffer<span class="p">&gt;</span>
<span class="se">        \</span> <span class="k">call</span> plist#Write<span class="p">()</span>
<span class="k">endfunction</span>
</code></pre></div></div><p>Note that the <code class="highlighter-rouge">autocmd!</code> line means deleting every other <code class="highlighter-rouge">BufWriteCmd</code> and <code class="highlighter-rouge">FileWriteCmd</code> autocmds for that buffer, and the second line registers <code class="highlighter-rouge">BufWriteCmd</code> and <code class="highlighter-rouge">FileWriteCmd</code> for that buffer.</p><p>But when I saved after editing a *.strings file, I saw this error message:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;stdin&gt;: Property List error: Unable to convert string to correct encoding / JSON error: JSON text did not start with array or object and option to allow fragments not set.
</code></pre></div></div><p>After poking around, I found that the <code class="highlighter-rouge">fileencoding</code> is set to <code class="highlighter-rouge">latin1</code>. The original file is binary and we just replaced the contents of the buffer, the <code class="highlighter-rouge">fileencoding</code> was not properly set. So I just set it to UTF-8.</p><div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span><span class="p">!</span> <span class="nv">s:ConvertBinaryPlist</span><span class="p">()</span>
  <span class="k">silent</span><span class="p">!</span> execute <span class="s1">'%d'</span>
  <span class="k">call</span> plist#Read<span class="p">(</span><span class="m">1</span><span class="p">)</span>
  <span class="k">call</span> plist#ReadPost<span class="p">()</span>
  <span class="k">set</span> fileencoding<span class="p">=</span>utf<span class="m">-8</span>

  autocmd<span class="p">!</span> <span class="nb">BufWriteCmd</span><span class="p">,</span><span class="nb">FileWriteCmd</span> <span class="p">&lt;</span>buffer<span class="p">&gt;</span>
  autocmd <span class="nb">BufWriteCmd</span><span class="p">,</span><span class="nb">FileWriteCmd</span> <span class="p">&lt;</span>buffer<span class="p">&gt;</span>
<span class="se">        \</span> <span class="k">call</span> plist#Write<span class="p">()</span>
<span class="k">endfunction</span>
</code></pre></div></div><h3>Saving a new file</h3><p>It’s simple:</p><div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code>autocmd <span class="nb">BufNewFile</span> *<span class="p">.</span>plist
<span class="se">      \</span> <span class="k">if</span> <span class="p">!</span>get<span class="p">(</span><span class="k">b</span><span class="p">:,</span> <span class="s1">'plist_original_format'</span><span class="p">)</span> <span class="p">|</span>
<span class="se">      \</span>   <span class="k">let</span> <span class="nv">b:plist_original_format</span> <span class="p">=</span> <span class="s1">'xml'</span> <span class="p">|</span>
<span class="se">      \</span> <span class="k">endif</span>
</code></pre></div></div><p>We don’t write binary file by our own hands, so a new plist file would be in xml format.</p><h2>Conclusion</h2><p>So this is the complete part of my .vimrc for binary plist files:</p><div class="language-vim highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span><span class="p">!</span> <span class="nv">s:ConvertBinaryPlist</span><span class="p">()</span>
  <span class="k">silent</span><span class="p">!</span> execute <span class="s1">'%d'</span>
  <span class="k">call</span> plist#Read<span class="p">(</span><span class="m">1</span><span class="p">)</span>
  <span class="k">call</span> plist#ReadPost<span class="p">()</span>
  <span class="k">set</span> fileencoding<span class="p">=</span>utf<span class="m">-8</span>

  autocmd<span class="p">!</span> <span class="nb">BufWriteCmd</span><span class="p">,</span><span class="nb">FileWriteCmd</span> <span class="p">&lt;</span>buffer<span class="p">&gt;</span>
  autocmd <span class="nb">BufWriteCmd</span><span class="p">,</span><span class="nb">FileWriteCmd</span> <span class="p">&lt;</span>buffer<span class="p">&gt;</span>
<span class="se">        \</span> <span class="k">call</span> plist#Write<span class="p">()</span>
<span class="k">endfunction</span>
autocmd <span class="nb">BufRead</span> *
<span class="se">      \</span> <span class="k">if</span> getline<span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="p">=~</span># <span class="s1">'^bplist'</span> <span class="p">|</span>
<span class="se">      \</span>   <span class="k">call</span> <span class="nv">s:ConvertBinaryPlist</span><span class="p">()</span> <span class="p">|</span>
<span class="se">      \</span> <span class="k">endif</span>
autocmd <span class="nb">BufNewFile</span> *<span class="p">.</span>plist
<span class="se">      \</span> <span class="k">if</span> <span class="p">!</span>get<span class="p">(</span><span class="k">b</span><span class="p">:,</span> <span class="s1">'plist_original_format'</span><span class="p">)</span> <span class="p">|</span>
<span class="se">      \</span>   <span class="k">let</span> <span class="nv">b:plist_original_format</span> <span class="p">=</span> <span class="s1">'xml'</span> <span class="p">|</span>
<span class="se">      \</span> <span class="k">endif</span>
</code></pre></div></div><p>It’s also available on <a href="https://github.com/yous/dotfiles/blob/ab9bf598d5bdb7c8d83a52f0ce18c66101db857c/vimrc#L1420-L1438">GitHub</a>, you can visit my <a href="https://github.com/yous/dotfiles">dotfiles</a> repository!</p></div></article></div></main><footer class="site-footer"><div class="wrapper"><p> Content on this site is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a><br /> &copy; 2013&ndash;2019 - <a href="/about/">Yous</a> - Powered by <a href="https://jekyllrb.com">Jekyll</a> &amp; <a href="https://github.com/yous/whiteglass">whiteglass</a> - Subscribe via <a href="https://yous.be/atom.xml">RSS</a></p></div></footer>
